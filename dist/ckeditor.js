/* !
 * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md.
 */
!( function( t, e ) { typeof exports == 'object' && typeof module == 'object' ? module.exports = e( require( 'vue' ) ) : typeof define == 'function' && define.amd ? define( [ 'vue' ], e ) : typeof exports == 'object' ? exports.CKEditor = e( require( 'vue' ) ) : t.CKEditor = e( t.Vue ); }( window, ( function( t ) { return ( function( t ) { const e = {}; function n( r ) { if ( e[ r ] ) { return e[ r ].exports; } const o = e[ r ] = { i: r, l: !1, exports: {} }; return t[ r ].call( o.exports, o, o.exports, n ), o.l = !0, o.exports; } return n.m = t, n.c = e, n.d = function( t, e, r ) { n.o( t, e ) || Object.defineProperty( t, e, { enumerable: !0, get: r } ); }, n.r = function( t ) { typeof Symbol != 'undefined' && Symbol.toStringTag && Object.defineProperty( t, Symbol.toStringTag, { value: 'Module' } ), Object.defineProperty( t, '__esModule', { value: !0 } ); }, n.t = function( t, e ) { if ( 1 & e && ( t = n( t ) ), 8 & e ) { return t; } if ( 4 & e && typeof t == 'object' && t && t.__esModule ) { return t; } const r = Object.create( null ); if ( n.r( r ), Object.defineProperty( r, 'default', { enumerable: !0, value: t } ), 2 & e && typeof t != 'string' ) { for ( const o in t ) { n.d( r, o, function( e ) { return t[ e ]; }.bind( null, o ) ); } } return r; }, n.n = function( t ) { const e = t && t.__esModule ? function() { return t.default; } : function() { return t; }; return n.d( e, 'a', e ), e; }, n.o = function( t, e ) { return Object.prototype.hasOwnProperty.call( t, e ); }, n.p = '', n( n.s = 3 ); }( [ function( e, n ) { e.exports = t; }, function( t, e, n ) { 'use strict'; ( function( t ) { const n = typeof t == 'object' && t && t.Object === Object && t; e.a = n; } ).call( this, n( 2 ) ); }, function( t, e ) { let n; n = ( function() { return this; }() ); try { n = n || new Function( 'return this' )(); } catch ( t ) { typeof window == 'object' && ( n = window ); }t.exports = n; }, function( t, e, n ) { 'use strict'; n.r( e ); const r = n( 0 ); const o = n.n( r ); const i = function( t ) { const e = typeof t; return t != null && ( e == 'object' || e == 'function' ); }; const u = n( 1 ); const a = typeof self == 'object' && self && self.Object === Object && self; const c = u.a || a || Function( 'return this' )(); const s = function() { return c.Date.now(); }; const l = /\s/; const f = function( t ) { for ( var e = t.length; e-- && l.test( t.charAt( e ) ); ) { } return e; }; const d = /^\s+/; const p = function( t ) { return t ? t.slice( 0, f( t ) + 1 ).replace( d, '' ) : t; }; const v = c.Symbol; const m = Object.prototype; const h = m.hasOwnProperty; const y = m.toString; const b = v ? v.toStringTag : void 0; const g = function( t ) { const e = h.call( t, b ); const n = t[ b ]; try { t[ b ] = void 0; var r = !0; } catch ( t ) {} const o = y.call( t ); return r && ( e ? t[ b ] = n : delete t[ b ] ), o; }; const j = Object.prototype.toString; const $ = function( t ) { return j.call( t ); }; const O = v ? v.toStringTag : void 0; const w = function( t ) { return t == null ? void 0 === t ? '[object Undefined]' : '[object Null]' : O && O in Object( t ) ? g( t ) : $( t ); }; const _ = function( t ) { return t != null && typeof t == 'object'; }; const x = function( t ) { return typeof t == 'symbol' || _( t ) && w( t ) == '[object Symbol]'; }; const S = /^[-+]0x[0-9a-f]+$/i; const E = /^0b[01]+$/i; const T = /^0o[0-7]+$/i; const V = parseInt; const D = function( t ) { if ( typeof t == 'number' ) { return t; } if ( x( t ) ) { return NaN; } if ( i( t ) ) { const e = typeof t.valueOf == 'function' ? t.valueOf() : t; t = i( e ) ? String( e ) : e; } if ( typeof t != 'string' ) { return t === 0 ? t : Number( t ); } t = p( t ); const n = E.test( t ); return n || T.test( t ) ? V( t.slice( 2 ), n ? 2 : 8 ) : S.test( t ) ? NaN : Number( t ); }; const N = Math.max; const k = Math.min; const M = function( t, e, n ) { let r; let o; let u; let a; let c; let l; let f = 0; let d = !1; let p = !1; let v = !0; if ( typeof t != 'function' ) { throw new TypeError( 'Expected a function' ); } function m( e ) { const n = r; const i = o; return r = o = void 0, f = e, a = t.apply( i, n ); } function h( t ) { return f = t, c = setTimeout( b, e ), d ? m( t ) : a; } function y( t ) { const n = t - l; return void 0 === l || n >= e || n < 0 || p && t - f >= u; } function b() { const t = s(); if ( y( t ) ) { return g( t ); } c = setTimeout( b, ( function( t ) { const n = e - ( t - l ); return p ? k( n, u - ( t - f ) ) : n; }( t ) ) ); } function g( t ) { return c = void 0, v && r ? m( t ) : ( r = o = void 0, a ); } function j() { const t = s(); const n = y( t ); if ( r = arguments, o = this, l = t, n ) { if ( void 0 === c ) { return h( l ); } if ( p ) { return clearTimeout( c ), c = setTimeout( b, e ), m( l ); } } return void 0 === c && ( c = setTimeout( b, e ) ), a; } return e = D( e ) || 0, i( n ) && ( d = !!n.leading, u = ( p = 'maxWait' in n ) ? N( D( n.maxWait ) || 0, e ) : u, v = 'trailing' in n ? !!n.trailing : v ), j.cancel = function() { void 0 !== c && clearTimeout( c ), f = 0, r = l = o = c = void 0; }, j.flush = function() { return void 0 === c ? a : g( s() ); }, j; }; const P = { name: 'ckeditor', render() { return Object( r.h )( this.tagName ); }, model: { prop: 'modelValue', event: 'update:modelValue' }, props: { editor: { type: Function, default: null }, modelValue: { type: String, default: '' }, config: { type: Object, default: () => ( {} ) }, tagName: { type: String, default: 'div' }, disabled: { type: Boolean, default: !1 } }, data: () => ( { $_instance: null, $_lastEditorData: { type: String, default: '' } } ), mounted() { const t = Object.assign( {}, this.config ); this.modelValue && ( t.initialData = this.modelValue ), this.editor.create( this.$el, t ).then( t => { this.$_instance = t, t.isReadOnly = this.disabled, this.$_setUpEditorEvents(), this.$emit( 'ready', t ); } ).catch( t => { console.error( t ); } ); }, beforeUnmount() { this.$_instance && ( this.$_instance.destroy(), this.$_instance = null ), this.$emit( 'destroy', this.$_instance ); }, watch: { modelValue( t, e ) { t !== e && t !== this.$_lastEditorData && this.$_instance.setData( t ); }, disabled( t ) { this.$_instance.isReadOnly = t; } }, methods: { $_setUpEditorEvents() { const t = this.$_instance; const e = M( e => { const n = this.$_lastEditorData = t.getData(); this.$emit( 'update:modelValue', n, e, t ), this.$emit( 'input', n, e, t ); }, 300, { leading: !0 } ); t.model.document.on( 'change:data', e ), t.editing.view.document.on( 'focus', e => { this.$emit( 'focus', e, t ); } ), t.editing.view.document.on( 'blur', e => { this.$emit( 'blur', e, t ); } ); } } }; const F = o.a ? o.a.version : r.version; const [ U ] = F.split( '.' ).map( t => parseInt( t, 10 ) ); if ( U < 3 ) { throw new Error( 'The CKEditor plugin works only with Vue 3+. For more information, please refer to https://ckeditor.com/docs/ckeditor5/latest/builds/guides/integration/frameworks/vuejs-v3.html' ); } const C = { install( t ) { t.component( 'ckeditor', P ); }, component: P }; e.default = C; } ] ) ).default; } ) ) );
// # sourceMappingURL=ckeditor.js.map
